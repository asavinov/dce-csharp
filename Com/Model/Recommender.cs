using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace Com.Model
{
    /// <summary>
    /// It is a whole space of all recommendations for a specific type of result, query/analysis. 
    /// This result is normally generated by one method (or a few alterantive methods) and is used by one UI component for one pattern. 
    /// Each field represents a recommendation-specific dimension (list) with the relevant options represented by recommendation fragment objects.
    /// All more specific recommendations are derived from this class. 
    /// </summary>
    public class Recommender
    {
        protected bool IsUpdating = false;
        protected string LastUpdated = null;

        // All possible recommendations as a list of complete recommendation objects. 
        public Fragments<object> Recommendations { get; set; }

        // Incremental part of recommendastion
        // Assume that the specified fragment has changed its selection, update all other fragment selections as well as relevances and other parameters.
        protected virtual void UpdateFragmentSelections(string selected) { }

        public virtual void UpdateSelection(string selected) { }

        public virtual Expression GetExpression() { return null; }

        public virtual string IsValidExpression() { return null; }

        public virtual void Recommend() { }

        public virtual void Clear() { Recommendations.Alternatives.Clear(); }

        public Recommender()
        {
            Recommendations = new Fragments<object>();
        }
    }

    /// <summary>
    /// Recommendation objects are of type Expression representing suggested aggregation expressions.
    /// </summary>
    public class RecommendedRelationships : Recommender
    {
        public ComTable SourceSet { get; set; }
        public ComTable TargetSet { get; set; }
        public ComTable FactSet { get; set; }

        public Fragments<List<ComColumn>> GroupingPaths { get; set; }
        public Fragments<ComTable> FactSets { get; set; }
        public Fragments<List<ComColumn>> MeasurePaths { get; set; }

        public override void UpdateSelection(string selected)
        {
            if (IsUpdating == true) return; // Prevent calling this method recursively

            IsUpdating = true;
            LastUpdated = selected;

            // Reset all
            GroupingPaths.Alternatives.ForEach(f => f.IsRelevant = true);
            FactSets.Alternatives.ForEach(f => f.IsRelevant = true);
            MeasurePaths.Alternatives.ForEach(f => f.IsRelevant = true);

            switch (selected)
            {
                case "GroupingPaths":
                    {
                        if (!GroupingPaths.IsSelected) break;

                        // Update FactSets
                        ComTable factSet = GroupingPaths.SelectedObject[0].LesserSet; // Find the fact set for this path
                        foreach (var f in FactSets.Alternatives)
                        {
                            f.IsRelevant = f.Fragment == factSet ? true : false; // Only one fact set is enabled
                            f.IsSelected = f.Fragment == factSet ? true : false; // And hence it is also selected
                        }

                        // Update MeasurePaths
                        int relevantCount = 0;
                        foreach (var f in MeasurePaths.Alternatives)
                        {
                            f.IsRelevant = ((List<ComColumn>)f.Fragment)[0].LesserSet == factSet ? true : false;
                            if (f.IsRelevant) relevantCount++;
                        }
                        if (MeasurePaths.SelectedFragment != null && !MeasurePaths.SelectedFragment.IsRelevant) MeasurePaths.SelectedFragment = null;
                        if (relevantCount == 1) MeasurePaths.Alternatives.ForEach(f => f.IsSelected = (f.IsRelevant ? true : false));

                        break;
                    }

                case "FactSets":
                    {
                        if (!FactSets.IsSelected) break;

                        ComTable factSet = FactSets.SelectedObject;

                        // Update GroupingPaths
                        int relevantCount = 0;
                        foreach (var f in GroupingPaths.Alternatives)
                        {
                            f.IsRelevant = ((List<ComColumn>)f.Fragment)[0].LesserSet == factSet ? true : false;
                            if (f.IsRelevant) relevantCount++;
                        }
                        if (GroupingPaths.SelectedFragment != null && !GroupingPaths.SelectedFragment.IsRelevant) GroupingPaths.SelectedFragment = null;
                        if (relevantCount == 1) GroupingPaths.Alternatives.ForEach(f => f.IsSelected = (f.IsRelevant ? true : false));

                        // Update MeasurePaths
                        relevantCount = 0;
                        foreach (var f in MeasurePaths.Alternatives)
                        {
                            f.IsRelevant = ((List<ComColumn>)f.Fragment)[0].LesserSet == factSet ? true : false;
                            if (f.IsRelevant) relevantCount++;
                        }
                        if (MeasurePaths.SelectedFragment != null && !MeasurePaths.SelectedFragment.IsRelevant) MeasurePaths.SelectedFragment = null;
                        if (relevantCount == 1) MeasurePaths.Alternatives.ForEach(f => f.IsSelected = (f.IsRelevant ? true : false));

                        break;
                    }

                case "MeasurePaths":
                    {
                        if (!MeasurePaths.IsSelected) break;

                        // Update FactSets
                        ComTable factSet = MeasurePaths.SelectedObject[0].LesserSet; // Find the fact set for this path
                        foreach (var f in FactSets.Alternatives)
                        {
                            f.IsRelevant = f.Fragment == factSet ? true : false; // Only one fact set is enabled
                            f.IsSelected = f.Fragment == factSet ? true : false; // And hence it is also selected
                        }

                        // Update GroupingPaths
                        int relevantCount = 0;
                        foreach (var f in GroupingPaths.Alternatives)
                        {
                            f.IsRelevant = ((List<ComColumn>)f.Fragment)[0].LesserSet == factSet ? true : false;
                            if (f.IsRelevant) relevantCount++;
                        }
                        if (GroupingPaths.SelectedFragment != null && !GroupingPaths.SelectedFragment.IsRelevant) GroupingPaths.SelectedFragment = null;
                        if (relevantCount == 1) GroupingPaths.Alternatives.ForEach(f => f.IsSelected = (f.IsRelevant ? true : false));

                        break;
                    }

            }

            IsUpdating = false;
        }

        public override Expression GetExpression()
        {
            var deprExpr = Com.Model.Expression.CreateDeprojectExpression(GroupingPaths.SelectedObject); // Grouping (deproject) expression: (Customers) <- (Orders) <- (Order Details)
            var projExpr = Com.Model.Expression.CreateProjectExpression(MeasurePaths.SelectedObject, Operation.DOT); // Measure (project) expression: (Order Details) -> (Product) -> List Price

            // TODO: here we need a method of Expression class to create a path expression (or relationships expression)

            return null;
        }

        public override string IsValidExpression()
        {
            if (GroupingPaths.SelectedObject == null) return "GroupingPaths";

            if (FactSet == null && FactSets.SelectedObject == null) return "FactSets";

            if (MeasurePaths.SelectedObject == null) return "MeasurePaths";

            return null;
        }

        /// <summary>
        /// Find all possible relationship paths from this set to the specified destination set via the specified lesser set.
        /// </summary>
        public override void Recommend()
        {
            //
            // 1. Find all possible lesser sets (relationship or fact sets)
            //
            var lesserSets = new List<ComTable>();
            if (this.FactSet != null) // Lesser set is provided
            {
                lesserSets.Add(this.FactSet);
            }
            else // Generate all possible lesser sets
            {
                // All least sets of the source set(s)
                var allPaths = new PathEnumerator(null, new List<ComTable> { this.SourceSet }, true, DimensionType.IDENTITY_ENTITY).ToList();
                // All lesser sets of the source set(s)
                foreach (var path in allPaths)
                {
                    foreach (ComColumn seg in path.Path)
                    {
                        if (!lesserSets.Contains(seg.LesserSet)) lesserSets.Add(seg.LesserSet);
                    }
                }
            }

            //
            // 2. Given a lesser set, find all relationship paths as pairs of <grouping path, measure path>
            //
            foreach (ComTable set in lesserSets)
            {
                var gPaths = new PathEnumerator(new List<ComTable> { set }, new List<ComTable> { this.SourceSet }, false, DimensionType.IDENTITY_ENTITY).ToList();
                var mPaths = new PathEnumerator(new List<ComTable> { set }, new List<ComTable> { this.TargetSet }, false, DimensionType.IDENTITY_ENTITY).ToList();

                if (gPaths.Count == 0) continue; // In fact, there must be at least one path - because the set is known to be a lesser set

                if (set == this.TargetSet) // Target (measure) set is the same as fact set
                {
                    List<ComColumn> loop = new List<ComColumn>();
                    loop.Add(new Dim(set));
                    mPaths.Add(new DimPath(loop));
                }

                if (mPaths.Count == 0) continue;

                RecommendedFragment<ComTable> frag = new RecommendedFragment<ComTable>(set, 1.0);
                this.FactSets.Alternatives.Add(frag);

                gPaths.ForEach(gp => this.GroupingPaths.Alternatives.Add(new RecommendedFragment<List<ComColumn>>(gp.Path, 1.0)));
                mPaths.ForEach(mp => this.MeasurePaths.Alternatives.Add(new RecommendedFragment<List<ComColumn>>(mp.Path, 1.0)));

                // For each pair of grouping paths build a complete relationship path
                foreach (var gp in gPaths)
                {
                    foreach (var mp in mPaths)
                    {
                        this.Recommendations.Alternatives.Add(new RecommendedFragment<object>(null, 1.0)); // TODO: build complete path or an object (tuple of indexes) representing a complete path
                    }
                }

            }
        }

        public override void Clear()
        {
            base.Clear();

            GroupingPaths.Alternatives.Clear();
            FactSets.Alternatives.Clear();
            MeasurePaths.Alternatives.Clear();
        }

        public RecommendedRelationships()
            : base()
        {
            GroupingPaths = new Fragments<List<ComColumn>>();
            FactSets = new Fragments<ComTable>();
            MeasurePaths = new Fragments<List<ComColumn>>();
        }
    }

    public class RecommendedAggregations : RecommendedRelationships
    {
        public Fragments<ComColumn> MeasureDimensions { get; set; }
        public Fragments<string> AggregationFunctions { get; set; }

        public override Expression GetExpression()
        {
            var deprExpr = Com.Model.Expression.CreateDeprojectExpression(GroupingPaths.SelectedObject);

            var measureDim = MeasureDimensions.SelectedObject;
            var measurePath = MeasurePaths.SelectedObject;
            if (measurePath.Count > 0)
            {
                if (measurePath[0].LesserSet == measurePath[measurePath.Count - 1].GreaterSet) // It is the case where we have a loop segment when measure table is the same as fact table
                {
                    measurePath.Clear();
                }
            }
            measurePath.Add(measureDim);

            var projExpr = Com.Model.Expression.CreateProjectExpression(measurePath, Operation.DOT);

            var aggregExpr = Com.Model.Expression.CreateAggregateExpression(AggregationFunctions.SelectedObject, deprExpr, projExpr);

            return aggregExpr;
        }

        public override string IsValidExpression()
        {
            if (base.IsValidExpression() != null) return base.IsValidExpression();

            if (MeasureDimensions.SelectedObject == null) return "MeasureDimensions";

            if (AggregationFunctions.SelectedObject == null) return "AggregationFunctions";

            return null;
        }

        public override void Recommend()
        {
            base.Recommend();

            // Add more for aggregations
            MeasureDimensions.Alternatives.Clear();
            if (this.TargetSet != null)
            {
                foreach (ComColumn dim in this.TargetSet.GreaterDims)
                {
                    var frag = new RecommendedFragment<ComColumn>(dim, 1.0);
                    MeasureDimensions.Alternatives.Add(frag);
                }
            }

            AggregationFunctions.Alternatives.Clear();
            AggregationFunctions.Alternatives.Add(new RecommendedFragment<string>("SUM", 1.0));
            AggregationFunctions.Alternatives.Add(new RecommendedFragment<string>("AVG", 1.0));
        }

        public override void Clear()
        {
            base.Clear();

            MeasureDimensions.Alternatives.Clear();
            AggregationFunctions.Alternatives.Clear();
        }

        public RecommendedAggregations()
            : base()
        {
            MeasureDimensions = new Fragments<ComColumn>();
            AggregationFunctions = new Fragments<string>();
        }
    }

    /// <summary>
    /// It is one of many possible fragments within a more complex recommendation for a query, expression or pattern. 
    /// It represents one option among many alteranatives to be chosen by the user, that is, it is a coordinate along one dimension. 
    /// It is independent of the type of recommendation and this type can be stored in a field as enumeration. 
    /// If it is necessary to develop a more specific fragment the this class has to be extended by a subclass. 
    /// </summary>
    public class RecommendedFragment<T>
    {
        // Constant parameters
        public T Fragment { get; set; } // It is the fragment itself. It can be an expression, set, dimension, function etc.
        public double Relevance { get; set; } // Unconditional (initial) weight between 0 and 1. Generated by the suggestion procedure. 
        public int Index { get; set; } // It is the order/rank according to the relevance. 0 index corresponds to highest (best) relevance. 

        private string _displayName;
        public string DisplayName // Shown in List view. Can be generated from expression or the object, or set explicitly
        {
            get
            {
                if (_displayName != null) return _displayName;

                if (typeof(T) == typeof(string)) return (string)(object)Fragment;
                else if (typeof(T) == typeof(Set)) return ((Set)(object)Fragment).Name;
                else if (typeof(T) == typeof(Dim)) return ((Dim)(object)Fragment).Name;
                else if (typeof(T) == typeof(List<Dim>))
                {
                    List<ComColumn> path = (List<ComColumn>)(object)Fragment;
                    string name = "";
                    path.ForEach(seg => name += "." + seg.Name); // One version

                    if (path == null || path.Count == 0) return "<EMPTY PATH>";

                    name = "(" + path[0].LesserSet.Name + ") -> ";
                    foreach (ComColumn seg in path)
                    {
                        name += seg.Name + " -> ";
                    }
                    name += "(" + path[path.Count - 1].GreaterSet.Name + ")";

                    return name;
                }
                else if (typeof(T) == typeof(DimPath))
                {
                    DimPath path = (DimPath)(object)Fragment;
                    string name = path.ComplexName; // One version

                    name = "(" + path.LesserSet.Name + ") -> ";
                    foreach (ComColumn seg in path.Path)
                    {
                        name += seg.Name + " -> ";
                    }
                    name += "(" + path.GreaterSet.Name + ")";

                    return name;
                }
                else if (typeof(T) == typeof(DimTree))
                {
                    return ((DimTree)(object)Fragment).Dim.LesserSet.Name + ":" + ((DimTree)(object)Fragment).Dim.Name + ":" + ((DimTree)(object)Fragment).Set.Name;
                }
                else return "<UNKNOWN>";
            }
            set { _displayName = value; }
        }

        // UI (variable)
        public bool IsSelected { get; set; }
        public bool IsRelevant { get; set; } // Can be selected under the current constraints
        public double CurrentRelevance { get; set; } // Conditional relevance/weight depending on the curerent selection and other factors. 0 means that the component is disabled. 

        // We probably need support for soring items according their current weight, that is, getting first, second etc. Maybe some enumerator or support via ListView/WPF (filter/sorting)
        public int CurrentIndex { get; set; } // What entry number corresponds to this position. 0 for highest relevance. 

        // We might also provide support for coarse-grained categorization like HIGH, MID, LOW, DISABLED (so IsDisabled is a special case). The categories are defined by static parameters or dynamically calculated (equal intervals etc.)

        // We might also provide support for visualization like colors and icons. 

        public RecommendedFragment(T component, double relevance)
        {
            Fragment = component;
            Relevance = relevance;

            IsSelected = false;
            IsRelevant = true;
            CurrentRelevance = Relevance;
        }
    }

    public class Fragments<T>
    {
        public string Name { get; set; }
        public List<RecommendedFragment<T>> Alternatives { get; set; }
        public bool Readonly { get; set; } // Whether the selection can be changed from UI

        public bool IsSelected
        {
            get { return Alternatives.Exists(f => f.IsSelected); }
        }

        public RecommendedFragment<T> SelectedFragment // The currently chosen alternative (can be null)
        {
            get { return Alternatives.FirstOrDefault(f => f.IsSelected); }
            set
            {
                Alternatives.ForEach(f => f.IsSelected = false); // Reset the current selection
                if (value == null) return; // No selected element

                int sel = -1;
                sel = Alternatives.IndexOf(value); // Find element to be selected
                if (sel < 0) // Item does not exist. Add it.
                {
                    Alternatives.Add(value);
                }

                value.IsSelected = true;

                // TODO: Make selection in the selected node (symmetric selection).  Simply add the same fragment?
            }
        }

        public T SelectedObject
        {
            get { return SelectedFragment == null ? default(T) : SelectedFragment.Fragment; }
            set
            {
                Alternatives.ForEach(f => f.IsSelected = false); // Reset the current selection
                if (value == null) return; // No selected element

                RecommendedFragment<T> selFrag = Alternatives.FirstOrDefault(f => EqualityComparer<T>.Default.Equals(f.Fragment, value)); // Find element to be selected
                if (selFrag == null) // Item does not exist. Add it.
                {
                    selFrag = new RecommendedFragment<T>(value, 1.0);
                    Alternatives.Add(selFrag);
                }

                selFrag.IsSelected = true;
            }
        }

        public void SelectBest() // Select the best fragment with the highest relevance which is not disabled (that is, compatible with other selections)
        {
            var relevantAlternatives = Alternatives.Where(f => f.IsRelevant == true);
            double bestRelevance = relevantAlternatives.Max(f => f.Relevance);
            RecommendedFragment<T> bestFragment = relevantAlternatives.First(f => f.Relevance == bestRelevance);
            SelectedFragment = bestFragment; // Can be null which means reset selection
        }

        public Fragments()
        {
            Alternatives = new List<RecommendedFragment<T>>();
        }
    }

}

