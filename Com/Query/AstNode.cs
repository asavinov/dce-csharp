using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

using Com.Model;

using Offset = System.Int32;

namespace Com.Query
{
    public class AstNode : TreeNode<AstNode>
    {
        /// <summary>
        /// Type of syntactic node which corresponds to a syntactic rule.
        /// </summary>
        public AstRule Rule { get; set; }

        /// <summary>
        /// It is normally a leaf of an AST. Its content is normally not parsed. 
        /// It normally represents names of variables, set members as well as primitive values and literals.
        /// </summary>
        public string Name { get; set; }

        public AstNode GetChild(int child) { return (AstNode)Children[child]; }

        /// <summary>
        /// Analyze this syntactic node and generate instructions in the script context.
        /// </summary>
        public List<ScriptOp> TranslateNode()
        {
            // One node can be translated into a sequence of instructions

            // So compilation is needed because of the following properties:
            // - target operations are flat - no nesting 
            // - all target operations are very simple and are mapped directly to API operations
            // - any target operation applies some operation to context and changes some context object
            //   - in other words, any operation operates (reads/writes) only variables in the context
            //   - result field in this case is not needed - we use an output variable instead (which is typed in addition and always available for next instructions)
            // - advantage of having flat operations is easier to analyze and optimize (reorganize) because we see all operations in the list while nesting hides operations and context changes

            // The simplest approach is to introduce one unique variable storing an intermediate result of each generated instruction. 
            // In particular, variables will be created for each:
            // - nested projection/de-projection/dot operation. Do it mechanically and remember this variable as a parameter of another operation which consumes the result. So projection/de-projection always use variables - no other way is supported.
            // - nested product operation. Here member types must be variables so product supports only variables its member types - nothing else is supported. The variables are assigned before this operation by extracting the type definition (in nested manner). 
            // - if some function depends on another function then the evaluation operation is simply inserted before.
            // - if some function body is refactored then we change this function definition and insert another function definition and evaluation operations.

            // Problem:
            // Generated script instructions are stored in context or within other instructions (nested instructions). 
            // Function body definitions (vexpr) are stored within script instructions as child nodes (possibly directly as value context). 
            // When these script instructions will be executed, these parameters will be directly copied to the function objects.

            // Translation is reduced to introducing/inserting access by-name:
            // - to context variables storing a value of an operand generated by previous ops (rather than nested ops)
            // - to new functions storing data generated by previous ops and consumed by this operation
            // Sequence of translation: gen unique var/func name, extract operation and save result to this var, replace the extracted expr by the new var

            // Read/write operands represented by-variables. 
            // - Arguments of any flat operation are represented as a tuple of members
            // - Members may have attribute name to distinguish their role
            // - Dedicated role 'return' is used to represent a result. If absent, then context variable named 'return' is used for saving result.
            // - A member as usual stores a value. But we need to be able to store variables, which means storing a reference to a (shared) value.
            // - Variables as tuple members can point to a real value and have the same type as this value, for example, a primitive value or a function or a set.

            // Essentially, operations simulate procedure calls in PLs with procedure name and a list of parameters.
            // Script operations is simply an encoding of API calls - nothing more.
            // These operations should directly correspond to our API (of our engine) or use a relatively simple translation like call for each operand
            // Interpreter reads the code of operation and its arguments by preparing a normal API call(s). 
            // Here it is important how to find run-time objects for this API call given arguments 

            // QUESTION: how to represent operands by-value and by-reference (by-variable names)?
            // - each operand has a role/attribute name in any case
            // - !!! operands cannot store run-time references/objects because it is code which is bound only to variables in the context. variables play a role of *relative* identifiers
            // - operands cannot store run-time references to functions - they can reference functions only by-name.
            // - operands can contain encoded values - primitive values, tuples, function definitions (incl. bodies) etc.
            //   - primitive values can be encoded as string (or even converted into a run-time object)
            //   - tuples could be encoded as TUPLE nodes (why not to use value-ops any value expression?)
            //   - function bodies could be encoded as a lambda, particularly, value expression - these arguments are needed for function creation operator
            // - only context state (variables) store real run-time objects and this is why we need to separate code from context (code is relative to context and hence run-time independent)
            // - we can resolve variables/functions during execution. for each operation, we find the named context variable (Variable) or function (Dim) or set (Set) as a run-time object which contains the necessary data (value, array etc.)
            // - alternatively, we can resolve variables/function names in advance and store these references in a special field. However, this requires that all variables/function have been already allocated which is not always so because they are allocated only at run-time. 
            // - for each named argument, we can add information about what kind of variable it references. This is determined during tanslation from AST and from information that is available only during translation. It can be necessary for later resolution (say, if a variable has the same name as a function then we have to determine the role from the context and cannot use simply the name because it is ambigous).
            // - an argument with variable could still have a field for a run-time value. In the case variable, it is copied from this variable. In the case of encoded value it is either decoded or written their. In the case of expression, it is computed. 
            // - So we need to distinguish between: 
            //   - encoded values/references using this instruction set (strings, names) like "my_func", "25.5", "my_var"
            //   - encoded structured values like TUPLE(..., TUPLE(...), ...) - do we use them in scripts?
            //   - run-time values that can be used for API call. these C# objects 
            //   - variable names refering to the context object by-name like "my_var"
            //   - variable object with direct access to the context object of type Variable. it is C# reference.

            // What do we need for scripts?
            // In scripts, we define sets and functions using existing sets and function bodies as vexpr.
            // Existing sets are represented exclusively by variable names which store run-time references. These references are returned by various methods. 
            // Function objects are also stored in variables where they are stored by various methods.
            // Functions are also used by their member-names relative to sets which are "allocated" during function creation. 
            // !!! vexpr can be used in script ops as parameters. These are values used as part of a function definition. 


            // One option is to retain nested operations but flatten then using depth-first strategy for operation execution (which in fact will be applied in the case of recursive execution)
            // In other words, recursive execution is always a sequential execution where the previous result is passed to the next operation as argument.

            // In fact, translation strategy of ast is reduced to flattening recursion. 
            // Child nodes are translated independently into operations, and then these operations are inserted before the instructions results from the parent ast node. 
            
            List<ScriptOp> scriptOps = new List<ScriptOp>();

            if (Rule == AstRule.SCRIPT) // Sequentially process all statements and merge all generated instructions
            {
                int stmtCount = Children.Count;
                for (int s = 0; s < stmtCount; s++)
                {
                    AstNode stmt = GetChild(s);
                    List<ScriptOp> stmtOps = stmt.TranslateNode();

                    scriptOps.AddRange(stmtOps);
                }
            }
            else if (Rule == AstRule.RETURN)
            {
                // Assign the expression to the 'return' variable
                throw new NotImplementedException();
            }
            else if (Rule == AstRule.ALLOC)
            {
                // Allocate variable (directly execute this instruction)
                //ContextVariable var = new ContextVariable(stmt.GetChild(0).Name, stmt.GetChild(1).Name);
                //scriptCtx.Variables.Add(var);

                // If there is initialization then process it and assign to the variable
                if (Children.Count > 2 && GetChild(2).Rule == AstRule.SEXPR)
                {
                    // Generate code for expression

                    // Assign result of execution of the previous operation to the variable
                }
            }
            else if (Rule == AstRule.ASSIGNMENT)
            {
                // Here a value is copied to an existing variable. 
                // It is equivalent to an expression except that an output argument is specified explicitly as a user-specified variable (rather than temporary allocated variable for intermediate expressions or no output).
                // The expression can result in many instructions and intermediate variables due to unnesting
                throw new NotImplementedException();
            }
            else if (Rule == AstRule.SEXPR)
            {
                // Flatenning nested expressions

                // If arguments are computed then recursively generated expressions for their computation
                // The result of argument computation is assigned to a variable (instruction is generated)

                // The new variables are used in the instruction for this node as arguments
                // Generate one instruction for this node depending on operation: projection, set creation, function definition, or arbitrary method call from API etc.
                // Direct API calls for: open connection, load tables, evaluation, resolving names etc.
                // Special constructs: set creation (product), projection/de-projection, function creation.

                // Generate output by combining instructions
                // Insert nested instructions in the return list before this node instruction
                throw new NotImplementedException();
            }

            return scriptOps;
        }

        /// <summary>
        /// Analyze this syntactic node and generate instructions in the value context defining a function.
        /// </summary>
        public ValueContext TranslateFunction()
        {
            return null;
        }

/*
        /// <summary>
        /// Where this node is a child.
        /// </summary>
        public AstNode Parent { get; set; }
        public AstNode Root
        {
            get
            {
                AstNode root = this;
                while (root.Parent != null)
                {
                    root = root.Parent;
                }

                return root;
            }
        }

        /// <summary>
        /// Child nodes.
        /// </summary>
        public List<AstNode> Children { get; set; }
        public int AddChild(AstNode child)
        {
            if (child == null) return -1;
            // TODO: We have to semantically check the validity of this child expression in the context of its parent expression, for example, by checking gramma rules

            int res = Children.IndexOf(child);
            if (res >= 0 && res < Children.Count)
            {
                Debug.Assert(child.Parent == this, "Wrong use: child expression must reference its parent");
                return res; // Already exists
            }

            if (child.Parent != null) child.Parent.RemoveChild(child);

            Children.Add(child);
            child.Parent = this;

            return Children.Count - 1;
        }
        public int RemoveChild(AstNode child)
        {
            int res = -1;
            res = Children.IndexOf(child);

            if (res >= 0) // Found
            {
                Children.RemoveAt(res);
            }

            if (child.Parent != null && child.Parent == this) child.Parent = null;

            return res;
        }
        public List<AstNode> GetChildren(AstRule op)
        {
            List<AstNode> res = new List<AstNode>();

            // Proces this element
            if (Rule == op) res.Add(this);

            // Recursively check all children
            Children.ForEach(e => res.AddRange(e.GetChildren(op)));

            return res;
        }
        public List<AstNode> GetLeaves(AstRule op) // Get a list of nodes which have the specified operation but no children with this operation. It is normally used to get nodes corresponding to primitive paths in a complex tuple.
        {
            List<AstNode> res = new List<AstNode>();

            if (Rule != op)
            {
                return res; // Empty means that there are no leaves here and down the tree
            }
            // This node *can* be a leaf (provided if it has no children with the operation)

            // Recursively check all children
            foreach (AstNode child in Children)
            {
                res.AddRange(child.GetLeaves(op));
            }

            if (res.Count == 0) res.Add(this); // It is a leaf

            return res;
        }
        public bool IsLeaf { get { return Children.Count == 0; } }

        public List<AstNode> GetRootPath() // Return a node list with nodes starting from the root (if it has a non-null dimension) and ending with this node
        {
            List<AstNode> path = new List<AstNode>();

            for (AstNode node = this; node != null; node = node.Parent)
            {
                path.Insert(0, node);
            }

            return path;
        }
*/

        public AstNode(string name)
            : this()
        {
            Name = name;
            Rule = AstRule.NAME;
        }

        public AstNode()
        {
            Rule = AstRule.NONE;
        }

    }

    public enum AstRule
    {
        NONE,

        //
        // Sexpr
        //

        SCRIPT, // List of set statements. A program for set processing.

        STATEMENT, // Statement in a script
        ALLOC, // Allocation/declaration of a new variable (with optional initialization)
        FREE, // Allocation/declaration of a new variable (with optional initialization)

        ASSIGNMENT, // Assignment to an existing variable: "myVar=sexpr;"
        RETURN, // Return. Semantically, it is similar assignment: "return sexpr;"

        SEXPR, // Set-oriented expression. It evaluates to a set by applying operations (and functions) to other sets.
        PROJECTION, // Operation of applying a function to a set which evaluates to another set
        DEPROJECTION, // Deprojection
        PRODUCT, // New set is defined as a product of greater sets as well as other members. Syntactically, it is a list of members of various types. 

        //
        // Vexpr
        //

        VSCOPE, // Scope in vexpr including delimiting the whole function body: { vexpr1; vexpr2; }
        DOT, // 
        TUPLE, // Tuple

        // Unary
        NEG,
        NOT,

        // Arithmetics
        MUL,
        DIV,
        ADD,
        SUB,

        // Logic
        LEQ,
        GEQ,
        GRE,
        LES,

        EQ,
        NEQ,

        AND,
        OR,

        //
        // Common
        //

        CALL, // Function (by-name or by-def) applied to something. Used in both vexpr (applied to one value) and sexpr (applied to all).
        PARAM, // It is a parameter of a call
        MEMBER, // It is a node in a product (set) or tuple definition: "type name=vexpr"

        NAME, // Any identifier like name of a set member, variable, argument, function etc.
        TYPE, // Value type. It is a role of a child node like member of set (product) or tuple.

        LITERAL, // Literal. A single primitive value
    }
}
